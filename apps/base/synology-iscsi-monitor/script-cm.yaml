apiVersion: v1
kind: ConfigMap
metadata:
  name: synology-iscsi-exporter-script
  namespace: synology-iscsi-monitor
data:
  exporter.py: |
    """Synology iSCSI Prometheus exporter.

    Connects to a Synology NAS via SSH and parses iSCSI target/LUN
    configuration files to expose per-LUN metrics with labels for
    environment, app, namespace, and PVC name.
    """

    import os
    import re
    import time

    import paramiko
    from prometheus_client import start_http_server, Gauge

    SYNOLOGY_IP = os.environ.get("SYNOLOGY_IP", "192.168.5.8")
    SYNOLOGY_USER = os.environ.get("SYNOLOGY_USER", "melodic-muse-app")
    SYNOLOGY_PASSWORD = os.environ.get("SYNOLOGY_PASSWORD", "")
    POLL_INTERVAL = int(os.environ.get("POLL_INTERVAL", "60"))

    TARGET_CONF = "/usr/syno/etc/iscsi_target.conf"
    LUN_CONF = "/usr/syno/etc/iscsi_lun.conf"

    # --- Aggregate metrics (backward-compatible) ---
    ISCSI_TARGET_COUNT = Gauge(
        "synology_iscsi_target_count",
        "Number of iSCSI targets configured",
    )
    ISCSI_LUN_COUNT = Gauge(
        "synology_iscsi_lun_count",
        "Number of iSCSI LUNs configured",
    )

    # --- Per-LUN metrics ---
    ISCSI_LUN_SIZE = Gauge(
        "synology_iscsi_lun_size_bytes",
        "Size of each iSCSI LUN in bytes",
        ["app", "environment", "namespace", "pvc"],
    )


    def _ssh_read_file(client, filepath):
        """Read entire remote file via an open SSH client."""
        _, stdout, stderr = client.exec_command(f"cat {filepath}")
        err = stderr.read().decode().strip()
        if err:
            print(f"stderr reading {filepath}: {err}")
        return stdout.read().decode()


    def _parse_ini_sections(text):
        """Parse a simple INI-style config into a list of dicts.

        Each section is delimited by a ``[header]`` line.  Key=value
        pairs within the section are collected into a dict.  The special
        key ``_section`` holds the header name.
        """
        sections = []
        current = None
        for line in text.splitlines():
            line = line.strip()
            m = re.match(r"^\[(.+)\]$", line)
            if m:
                current = {"_section": m.group(1)}
                sections.append(current)
                continue
            if current is not None and "=" in line:
                key, _, value = line.partition("=")
                current[key.strip()] = value.strip()
        return sections


    def _derive_env_and_app(namespace):
        """Derive environment and app name from a Kubernetes namespace.

        Convention:
          ``<app>-stage``  -> environment=staging,  app=<app>
          ``<app>-prod``   -> environment=production, app=<app>
          anything else    -> environment=infra,     app=<namespace>
        """
        if namespace.endswith("-stage"):
            return "staging", namespace[: -len("-stage")]
        if namespace.endswith("-prod"):
            return "production", namespace[: -len("-prod")]
        return "infra", namespace


    def _collect_targets(client):
        """Count iSCSI target sections in the target config."""
        text = _ssh_read_file(client, TARGET_CONF)
        count = sum(1 for s in _parse_ini_sections(text)
                    if s["_section"].startswith("iSCSI_T"))
        ISCSI_TARGET_COUNT.set(count)
        return count


    def _collect_luns(client):
        """Parse LUN config and expose per-LUN size metrics."""
        text = _ssh_read_file(client, LUN_CONF)
        sections = _parse_ini_sections(text)

        # Total section count (backward-compatible aggregate)
        ISCSI_LUN_COUNT.set(len(sections))

        # Clear stale label sets from previous scrape
        ISCSI_LUN_SIZE._metrics.clear()

        detailed = 0
        for section in sections:
            description = section.get("description", "")
            size_bytes = section.get("bytes", "0")

            if not description or "/" not in description:
                continue  # skip sections without k8s metadata

            namespace, pvc = description.split("/", 1)
            environment, app = _derive_env_and_app(namespace)

            try:
                size = int(size_bytes)
            except ValueError:
                size = 0

            ISCSI_LUN_SIZE.labels(
                app=app,
                environment=environment,
                namespace=namespace,
                pvc=pvc,
            ).set(size)
            detailed += 1

        return len(sections)


    def collect():
        """Run a single collection cycle."""
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            client.connect(
                SYNOLOGY_IP,
                username=SYNOLOGY_USER,
                password=SYNOLOGY_PASSWORD,
                timeout=10,
            )
            targets = _collect_targets(client)
            luns = _collect_luns(client)
            print(f"Metrics updated: Targets={targets}, LUNs={luns}")
        except Exception as e:
            print(f"Error during collection: {e}")
        finally:
            client.close()


    if __name__ == "__main__":
        print("Starting Synology iSCSI Exporter on :8000")
        start_http_server(8000)
        while True:
            collect()
            time.sleep(POLL_INTERVAL)
